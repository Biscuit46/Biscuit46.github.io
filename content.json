{"pages":[{"title":"","text":"2019.1 2019.1.4 Blog开启","link":"/about/index.html"},{"title":"","text":"本校julao神仙的学长/学弟/同级同学们: ZCDHJ zcdhj.org hyjhyj www.cnblogs.com/heyujun 聊天鬼才hbx www.cnblogs.com/hbxblog 坠强的yyb www.cnblogs.com/cjyyb cjoier_zouzhen1211 blog.csdn.net/zz3111057382","link":"/friends/index.html"}],"posts":[{"title":"BZOJ3209 - 花神的数论题","text":"传送门BZOJ洛谷 Solution我们考虑一下令$sum_i=x$,那么显然可以发现直接按照组合数算,注意如果位数和n相同要一位一位的比. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}ll n,ts,c[120][120],ans[120];int ws;const ll Mod=10000007;ll C(int n,int m){ if(n&lt;0 || m&lt;0)return 0; if(n&lt;m)return 0; return c[n][m];}ll qpow(ll a,ll b){ll ret=1;while(b){if(b&amp;1)ret=(ret*a)%Mod;b&gt;&gt;=1;a=(a*a)%Mod;}return ret;}void Add(ll &amp;x,ll y){x+=y;}int main(){ scanf(\"%lld\",&amp;n); ts=n;int ws=0; while(ts){ ts&gt;&gt;=1ll;ws++; } for(int i=0;i&lt;=ws+10;i++){ c[i][0]=c[i][i]=1; for(int j=1;j&lt;i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1]; } for(int i=1;i&lt;=ws;i++){ for(int j=i;j&lt;ws;j++) Add(ans[i],C(j-1,i-1)); int one=0; for(int k=ws;k&gt;=1;k--){//前ws-k+1位相同 if(n&amp;(1ll&lt;&lt;(k-1)))one++; if(n&amp;(1ll&lt;&lt;(k-2)))Add(ans[i],C(k-2,i-one)); } } ts=n;int p=0; while(ts){if(ts&amp;1ll)p++;ts&gt;&gt;=1;} ans[p]++;ll reans=1; for(int i=1;i&lt;=ws;i++)reans=(reans*qpow(i,ans[i]))%Mod; printf(\"%lld\\n\",reans); return 0;}","link":"/2019/01/05/BZOJ3209/"},{"title":"BZOJ4005 - 骗我呢","text":"传送门BZOJ Solution考虑一下最为朴素的dp,不是直接前缀和优化一下然后随便乱搞就可以有$\\Theta(n^2)$的做法吗?然后就可以考虑一下这个东西的组合意义,不相当于是把所有的往右平移一下然后就可以了?接着要保证不能碰到两根线,所以需要多次跳跃?希望大家能够感性理解一下(其实是我tcl)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int Mod=1e9+7;int inv[4000010],jc[5000010],jcn[5000010],n,m,N;void flip1(int &amp;x,int &amp;y){ swap(x,y);--x;++y;}void flip2(int &amp;x,int &amp;y){ swap(x,y);x+=m+2;y-=m+2;}int calc(int x,int y){ if(x&lt;0 || y&lt;0)return 0; return 1ll*jc[x+y]*jcn[x]%Mod*jcn[y]%Mod;}void Add(int &amp;x,int y){ x+=y;if(x&gt;=Mod)x-=Mod;}int main(){ n=gi();m=gi(); inv[0]=inv[1]=jc[0]=jcn[0]=1;N=max(n,m)*3+1; for(int i=2;i&lt;=N;i++)inv[i]=(Mod-1ll*Mod/i*inv[Mod%i]%Mod)%Mod; for(int i=1;i&lt;=N;i++)jc[i]=1ll*jc[i-1]*i%Mod,jcn[i]=1ll*jcn[i-1]*inv[i]%Mod; int x=n+m+1,y=n,ans=calc(x,y); while(x&gt;=0 &amp;&amp; y&gt;=0){ flip1(x,y);Add(ans,Mod-calc(x,y)); flip2(x,y);Add(ans,calc(x,y)); } x=n+m+1,y=n; while(x&gt;=0 &amp;&amp; y&gt;=0){ flip2(x,y);Add(ans,Mod-calc(x,y)); flip1(x,y);Add(ans,calc(x,y)); } printf(\"%d\\n\",ans); return 0;}","link":"/2019/01/04/lg3266/"},{"title":"HDU3045","text":"传送门HDU Solution考虑一下普通的DP,排个序直接转移就好了:1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}int n,t,a[500010],sum[500010],dp[500010];int main(){ while(scanf(\"%d\",&amp;n)==1){ t=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n;i++) memset(dp,127,sizeof(dp));dp[0]=0; for(int i=t;i&lt;=n;i++)//求dp[i]; for(int j=1;i-j+1&gt;=t;j++) dp[i]=min(dp[i],dp[j-1]+(sum[i]-sum[j-1])-a[j]*(i-j+1)); printf(\"%d\\n\",dp[n]); } return 0;} 接着想怎么优化:我们考虑一下它可以从下面这两个点(j,k)转移(k&lt;j)然后发现把他们两个的dp转移式展开,可以发现如果j&gt;k的话把与i有关的隔离开,然后移过去就好了.所以发现这个东西可以只和之前的有关,然后就可以用单调栈转移了.其实这个优化叫做斜率优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define int long long#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}int n,t,a[800010],sum[800010],dp[800010],q[800010];int dx(int j,int k){ return a[j+1]-a[k+1];}int dy(int j,int k){ return dp[j]-sum[j]+j*a[j+1]-(dp[k]-sum[k]+k*a[k+1]);}int getdp(int i,int j){ return dp[j]+(sum[i]-sum[j])-a[j+1]*(i-j);}signed main(){ while(scanf(\"%lld%lld\",&amp;n,&amp;t)==2){ for(int i=1;i&lt;=n;i++)a[i]=gi(); int head=0,tail=0;q[0]=0;q[1]=0;dp[0]=0; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n;i++){ while(head&lt;tail &amp;&amp; dy(q[head+1],q[head])&lt;=i*dx(q[head+1],q[head]))head++; dp[i]=getdp(i,q[head]); int j=i-t+1; if(j&lt;t)continue; while(head&lt;tail &amp;&amp; dy(j,q[tail])*dx(j,q[tail-1])&lt;=dy(j,q[tail-1])*dx(j,q[tail]))tail--; q[++tail]=j; } printf(\"%lld\\n\",dp[n]); } return 0;}","link":"/2019/01/04/HDU3045/"},{"title":"洛谷3994 - 高速公路","text":"传送门洛谷 Solution考虑一下暴力的树上dp,不就是直接随便乱搞一下子然后父亲给自己算贡献.然后这样子你就可以获得60pts.12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;stdlib.h&gt;#define ll long long#define int llll min(ll a,ll b){ return a&lt;b?a:b;}const int N=1000010;ll dp[N];int Time,to[N&lt;&lt;1],nxt[N&lt;&lt;1],front[N],cnt,siz[N],dfn[N],dis[N],w[N&lt;&lt;1],p[N],q[N],n,fa[N];void Add(int u,int v,int W){ to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;w[cnt]=W;}void dfs(int u,int Fa){ siz[u]=1;dfn[u]=++Time;fa[u]=Fa; for(int i=front[u];i;i=nxt[i]){ int v=to[i]; if(v==Fa)continue; dis[v]=dis[u]+w[i]; dfs(v,u);siz[u]+=siz[v]; }}void Dp(int u,int Fa){ int grandson=u; while(fa[grandson]){ grandson=fa[grandson]; dp[u]=min(dp[u],dp[grandson]+p[u]*(dis[u]-dis[grandson])+q[u]); } for(int i=front[u];i;i=nxt[i]){ int v=to[i]; if(v==Fa)continue; Dp(v,u); }}signed main(){ scanf(\"%lld\",&amp;n); for(int i=2;i&lt;=n;i++){ int f,W;scanf(\"%lld%lld%lld%lld\",&amp;f,&amp;W,&amp;p[i],&amp;q[i]); Add(f,i,W); } dfs(1,0); memset(dp,127,sizeof(dp));dp[1]=0;Dp(1,1); for(int i=2;i&lt;=n;i++)printf(\"%lld\\n\",dp[i]); return 0;} 然后考虑一下怎么优化?发现这个转移方程式可以写成一个一次函数,然后直接斜率优化就好了.123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define int long long#define re registerconst int N=50010;int c[N],sum[N],n,L,q[N];double dp[N];int head,tail;double a(int i){return sum[i]+i;}double b(int i){return a(i)+L+1;}double X(int i){return b(i);}double Y(int i){return dp[i]+b(i)*b(i);}double slope(int i,int j){return (Y(i)-Y(j))/(X(i)-X(j));}main(){ scanf(\"%lld%lld\",&amp;n,&amp;L); for(re int i=1;i&lt;=n;i++)scanf(\"%lld\",&amp;c[i]); for(re int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+c[i]; head=tail=1; for(int i=1;i&lt;=n;i++){ while(head&lt;tail &amp;&amp; slope(q[head],q[head+1])&lt;2*a(i))head++; dp[i]=dp[q[head]]+(a(i)-b(q[head]))*(a(i)-b(q[head])); while(head&lt;tail &amp;&amp; slope(i,q[tail-1])&lt;slope(q[tail-1],q[tail]))tail--; q[++tail]=i; } printf(\"%lld\\n\",(long long)dp[n]); return 0;}","link":"/2019/01/05/lg3994/"},{"title":"HDU4899","text":"传送门HDU Solution考虑一下LCS求的过程,显然要么和i-1有关系,要么和j-1有关系,然后就可以只存两行,然后发现这个东西可以很好的利用一下,相当于是说外面状压,里面把LCS压起来,然后直接转移就好了.总结起来叫做dp套dp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}char t[5]={' ','A','C','G','T'};const int Mod=1e9+7,maxn=15,maxm=1&lt;&lt;maxn,maxa=1e3+1;char s[maxn+1];int trans[maxm][5],f[maxa+2][maxm+2],ans[maxn+2],n,a[maxn+2],m;int change(char s){ for(int i=1;i&lt;=4;i++)if(t[i]==s)return i; return 5;}void Add(int &amp;x,int y){ x+=y;if(x&gt;=Mod)x-=Mod;}int count(int x){ int ret=0; for(int i=0;i&lt;15;i++)ret+=((x&gt;&gt;i)&amp;1); return ret;}int tf[2][20];int Trans(int sit,int c) { memset(tf,0,sizeof tf); for (int i=0;i&lt;n;++i) tf[0][i+1]=tf[0][i]+((sit&gt;&gt;i)&amp;1); for (int i=1;i&lt;=n;++i) { int tmp=0; if (a[i]==c) tmp=max(tmp,tf[0][i-1]+1); tmp=max(tmp,max(tf[0][i],tf[1][i-1])); tf[1][i]=tmp; } int ret=0; for (int i=0;i&lt;n;++i) ret+=(1&lt;&lt;i)*(tf[1][i+1]-tf[1][i]); return ret;}signed main(){ int Case;scanf(\"%d\",&amp;Case); while(Case--){ memset(ans,0,sizeof(ans)); memset(f,0,sizeof(f)); memset(a,0,sizeof(a)); scanf(\"%s\",s+1);scanf(\"%d\",&amp;m);n=strlen(s+1); f[0][0]=1; for(int i=1;i&lt;=n;i++)a[i]=change(s[i]); for(int j=0;j&lt;(1&lt;&lt;n);j++) for(int k=1;k&lt;=4;k++) trans[j][k]=Trans(j,k); for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) for(int k=1;k&lt;=4;k++){ int S=trans[j][k]; Add(f[i][S],f[i-1][j]); } for(int i=0;i&lt;(1&lt;&lt;n);i++)Add(ans[count(i)],f[m][i]); for(int i=0;i&lt;=n;i++)printf(\"%d\\n\",ans[i]); } return 0;}","link":"/2019/01/04/HDU4899/"},{"title":"BZOJ2439 - [中山市选2011] 序列","text":"传送门BZOJ Solution考虑一下可以把一个M分成两半.那么分别就是两个V.对于这两个V可以很容易的dp求解,然后直接搞一下就好了.1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=3000010;int a[N],n;ll f[N],l[N],r[N],g[N];int main(){ file(\"a\"); n=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi();a[0]=-1; for(int i=1;i&lt;=n;i++)f[i]=f[i-1]+max(0,a[i-1]-a[i]+1); for(int i=n;i&gt;=1;i--)g[i]=g[i+1]+max(0,a[i+1]-a[i]+1); int u=2; for(int i=3;i&lt;n-1;i++){ while(u&lt;i-1 &amp;&amp; max(f[u+1],g[u+1]-g[i])&lt;=max(f[u],g[u]-g[i]))u++; l[i]=max(f[u],g[u]-g[i]); } u=n-1; for(int i=n-2;i&gt;=3;--i){ while(u&gt;i+1 &amp;&amp; max(f[u-1]-f[i],g[u-1])&lt;=max(g[u],f[u]-f[i]))--u; r[i]=max(g[u],f[u]-f[i]); } ll ans=(1ll&lt;&lt;60); for(int i=3;i&lt;n-1;i++) ans=min(ans,l[i]+r[i]); printf(\"%lld\\n\",ans); return 0;}","link":"/2019/01/05/BZOJ2439/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"组合计数","slug":"组合计数","link":"/tags/组合计数/"},{"name":"容斥","slug":"容斥","link":"/tags/容斥/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"斜率优化","slug":"斜率优化","link":"/tags/斜率优化/"},{"name":"dop","slug":"dop","link":"/tags/dop/"},{"name":"决策单调性","slug":"决策单调性","link":"/tags/决策单调性/"}],"categories":[{"name":"Solution","slug":"Solution","link":"/categories/Solution/"}]}