{"pages":[],"posts":[{"title":"HDU3045","text":"考虑一下普通的DP,排个序直接转移就好了:1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}int n,t,a[500010],sum[500010],dp[500010];int main(){ while(scanf(\"%d\",&amp;n)==1){ t=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n;i++) memset(dp,127,sizeof(dp));dp[0]=0; for(int i=t;i&lt;=n;i++)//求dp[i]; for(int j=1;i-j+1&gt;=t;j++) dp[i]=min(dp[i],dp[j-1]+(sum[i]-sum[j-1])-a[j]*(i-j+1)); printf(\"%d\\n\",dp[n]); } return 0;} 接着想怎么优化:我们考虑一下它可以从下面这两个点(j,k)转移(k&lt;j)然后发现把他们两个的dp转移式展开,可以发现如果j&gt;k的话把与i有关的隔离开,然后移过去就好了.所以发现这个东西可以只和之前的有关,然后就可以用单调栈转移了.其实这个优化叫做斜率优化","link":"/2019/01/04/HDU3045/"}],"tags":[{"name":"DP 斜率优化","slug":"DP-斜率优化","link":"/tags/DP-斜率优化/"}],"categories":[{"name":"Solution","slug":"Solution","link":"/categories/Solution/"}]}