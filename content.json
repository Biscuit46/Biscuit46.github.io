{"pages":[{"title":"","text":"2019.1 2019.1.4 Blog开启","link":"/about/index.html"},{"title":"","text":"本校julao神仙的学长/学弟/同级同学们: ZCDHJ zcdhj.org hyjhyj www.cnblogs.com/heyujun 聊天鬼才hbx www.cnblogs.com/hbxblog 坠强的yyb www.cnblogs.com/cjyyb","link":"/friends/index.html"}],"posts":[{"title":"HDU3045","text":"传送门HDU Solution考虑一下普通的DP,排个序直接转移就好了:1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}int n,t,a[500010],sum[500010],dp[500010];int main(){ while(scanf(\"%d\",&amp;n)==1){ t=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n;i++) memset(dp,127,sizeof(dp));dp[0]=0; for(int i=t;i&lt;=n;i++)//求dp[i]; for(int j=1;i-j+1&gt;=t;j++) dp[i]=min(dp[i],dp[j-1]+(sum[i]-sum[j-1])-a[j]*(i-j+1)); printf(\"%d\\n\",dp[n]); } return 0;} 接着想怎么优化:我们考虑一下它可以从下面这两个点(j,k)转移(k&lt;j)然后发现把他们两个的dp转移式展开,可以发现如果j&gt;k的话把与i有关的隔离开,然后移过去就好了.所以发现这个东西可以只和之前的有关,然后就可以用单调栈转移了.其实这个优化叫做斜率优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define int long long#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}int n,t,a[800010],sum[800010],dp[800010],q[800010];int dx(int j,int k){ return a[j+1]-a[k+1];}int dy(int j,int k){ return dp[j]-sum[j]+j*a[j+1]-(dp[k]-sum[k]+k*a[k+1]);}int getdp(int i,int j){ return dp[j]+(sum[i]-sum[j])-a[j+1]*(i-j);}signed main(){ while(scanf(\"%lld%lld\",&amp;n,&amp;t)==2){ for(int i=1;i&lt;=n;i++)a[i]=gi(); int head=0,tail=0;q[0]=0;q[1]=0;dp[0]=0; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n;i++){ while(head&lt;tail &amp;&amp; dy(q[head+1],q[head])&lt;=i*dx(q[head+1],q[head]))head++; dp[i]=getdp(i,q[head]); int j=i-t+1; if(j&lt;t)continue; while(head&lt;tail &amp;&amp; dy(j,q[tail])*dx(j,q[tail-1])&lt;=dy(j,q[tail-1])*dx(j,q[tail]))tail--; q[++tail]=j; } printf(\"%lld\\n\",dp[n]); } return 0;}","link":"/2019/01/04/HDU3045/"},{"title":"HDU4899","text":"传送门HDU Solution考虑一下LCS求的过程,显然要么和i-1有关系,要么和j-1有关系,然后就可以只存两行,然后发现这个东西可以很好的利用一下,相当于是说外面状压,里面把LCS压起来,然后直接转移就好了.总结起来叫做dp套dp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}char t[5]={' ','A','C','G','T'};const int Mod=1e9+7,maxn=15,maxm=1&lt;&lt;maxn,maxa=1e3+1;char s[maxn+1];int trans[maxm][5],f[maxa+2][maxm+2],ans[maxn+2],n,a[maxn+2],m;int change(char s){ for(int i=1;i&lt;=4;i++)if(t[i]==s)return i; return 5;}void Add(int &amp;x,int y){ x+=y;if(x&gt;=Mod)x-=Mod;}int count(int x){ int ret=0; for(int i=0;i&lt;15;i++)ret+=((x&gt;&gt;i)&amp;1); return ret;}int tf[2][20];int Trans(int sit,int c) { memset(tf,0,sizeof tf); for (int i=0;i&lt;n;++i) tf[0][i+1]=tf[0][i]+((sit&gt;&gt;i)&amp;1); for (int i=1;i&lt;=n;++i) { int tmp=0; if (a[i]==c) tmp=max(tmp,tf[0][i-1]+1); tmp=max(tmp,max(tf[0][i],tf[1][i-1])); tf[1][i]=tmp; } int ret=0; for (int i=0;i&lt;n;++i) ret+=(1&lt;&lt;i)*(tf[1][i+1]-tf[1][i]); return ret;}signed main(){ int Case;scanf(\"%d\",&amp;Case); while(Case--){ memset(ans,0,sizeof(ans)); memset(f,0,sizeof(f)); memset(a,0,sizeof(a)); scanf(\"%s\",s+1);scanf(\"%d\",&amp;m);n=strlen(s+1); f[0][0]=1; for(int i=1;i&lt;=n;i++)a[i]=change(s[i]); for(int j=0;j&lt;(1&lt;&lt;n);j++) for(int k=1;k&lt;=4;k++) trans[j][k]=Trans(j,k); for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) for(int k=1;k&lt;=4;k++){ int S=trans[j][k]; Add(f[i][S],f[i-1][j]); } for(int i=0;i&lt;(1&lt;&lt;n);i++)Add(ans[count(i)],f[m][i]); for(int i=0;i&lt;=n;i++)printf(\"%d\\n\",ans[i]); } return 0;}","link":"/2019/01/04/HDU4899/"},{"title":"BZOJ4005 - 骗我呢","text":"传送门BZOJ Solution考虑一下最为朴素的dp,不是直接前缀和优化一下然后随便乱搞就可以有$\\Theta(n^2)$的做法吗?然后就可以考虑一下这个东西的组合意义,不相当于是把所有的往右平移一下然后就可以了?接着要保证不能碰到两根线,所以需要多次跳跃?希望大家能够感性理解一下(其实是我tcl)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int Mod=1e9+7;int inv[4000010],jc[5000010],jcn[5000010],n,m,N;void flip1(int &amp;x,int &amp;y){ swap(x,y);--x;++y;}void flip2(int &amp;x,int &amp;y){ swap(x,y);x+=m+2;y-=m+2;}int calc(int x,int y){ if(x&lt;0 || y&lt;0)return 0; return 1ll*jc[x+y]*jcn[x]%Mod*jcn[y]%Mod;}void Add(int &amp;x,int y){ x+=y;if(x&gt;=Mod)x-=Mod;}int main(){ n=gi();m=gi(); inv[0]=inv[1]=jc[0]=jcn[0]=1;N=max(n,m)*3+1; for(int i=2;i&lt;=N;i++)inv[i]=(Mod-1ll*Mod/i*inv[Mod%i]%Mod)%Mod; for(int i=1;i&lt;=N;i++)jc[i]=1ll*jc[i-1]*i%Mod,jcn[i]=1ll*jcn[i-1]*inv[i]%Mod; int x=n+m+1,y=n,ans=calc(x,y); while(x&gt;=0 &amp;&amp; y&gt;=0){ flip1(x,y);Add(ans,Mod-calc(x,y)); flip2(x,y);Add(ans,calc(x,y)); } x=n+m+1,y=n; while(x&gt;=0 &amp;&amp; y&gt;=0){ flip2(x,y);Add(ans,Mod-calc(x,y)); flip1(x,y);Add(ans,calc(x,y)); } printf(\"%d\\n\",ans); return 0;}","link":"/2019/01/04/lg3266/"}],"tags":[{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"容斥","slug":"容斥","link":"/tags/容斥/"}],"categories":[{"name":"Solution","slug":"Solution","link":"/categories/Solution/"}]}